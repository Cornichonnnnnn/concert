#! python

import sys
import os
import argparse
import subprocess
import logbook
import concert
import concert.session


def run_shell(handler, m=None):
    try:
        from IPython import embed
        import quantities as q

        if m:
            print m.__doc__

        banner = "Welcome to Concert {0}".format(concert.__version__)

        with handler.applicationbound():
            embed(banner1=banner)
    except ImportError as e:
        print("You must install IPython to run the Concert shell: %s" % e)


def exit_if_not_exists(session):
    if not concert.session.exists(session):
        message = "Session `{0}' does not exist. Run `concert init {0}' first."
        print(message.format(session))
        sys.exit(1)


def init_session(args):
    if concert.session.exists(args.session) and not args.force:
        message = "Session `{0}' already exists."
        message += " Use --force to create it anyway."
        print(message.format(args.session))
    else:
        concert.session.create(args.session)


def get_log_filename(args):
    """Return log filename from *args* or session default."""
    if args.logfile:
        return args.logfile
    else:
        return concert.session.DEFAULT_LOGFILE


def start_session(args):
    session = args.session
    exit_if_not_exists(session)
    module = concert.session.load(session)
    handler = None

    if args.logto == 'file':
        filename = get_log_filename(args)
        handler = logbook.FileHandler(filename)
    else:
        handler = logbook.StderrHandler()

    handler.format_string = '[{record.time}] {record.level_name}: \
%s: {record.channel}: {record.message}' % session
    run_shell(handler, module)


def edit_session(args):
    exit_if_not_exists(args.session)
    env = os.environ
    editor = env['EDITOR'] if 'EDITOR' in env else 'vi'
    subprocess.call([editor, concert.session.path(args.session)])


def remove_session(args):
    for session in args.sessions:
        print("Removing {0}...".format(session))
        concert.session.remove(session)


def show_log(args):
    logfile = concert.session.DEFAULT_LOGFILE

    # This is danger zone here because we run subprocess.call with shell=True.
    # However, the only input that we input is args.session which we check first
    # and the logfile itself.

    if args.session:
        exit_if_not_exists(args.session)
        cmd = 'grep "{0}:" {1} | less'.format(args.session, logfile)
    else:
        cmd = 'less {0}'.format(logfile)

    subprocess.call(cmd, shell=True)


def show_sessions(args):
    sessions = concert.session.get_existing()
    print("Available sessions:")

    for session in sessions:
        print("  %s" % session)


if __name__ == '__main__':
    if len(sys.argv) == 1:
        run_shell()
        sys.exit(0)

    parser = argparse.ArgumentParser()

    parser.add_argument('--version',
                        action='version',
                        version="Concert v%s " % concert.__version__)

    session_arg = {'session': {'type': str}}
    session_list = {'sessions': {'type': str,
                                 'nargs': '+',
                                 'metavar': 'session'}}

    commands = [('init', "Create a new session", init_session,
                    {
                        'session': {'type': str},
                        '--force': {'action': 'store_true',
                                    'help': "Overwrite existing sessions"}
                    }),
                ('edit', "Edit session details", edit_session, session_arg),
                ('rm', "Remove a session", remove_session, session_list),
                ('start', "Start a session", start_session,
                    {
                        'session': {'type': str},
                        '--logto': {'choices': ['stderr', 'file'],
                                    'default': 'file'},
                        '--logfile': {'type': str}
                    }),
                ('log', "Show log", show_log,
                    {
                        'session': {'type': str,
                                    'nargs': '?'}
                    }),
                ('show', "Show existing sessions", show_sessions, {})]

    subparsers = parser.add_subparsers(title="Concert commands",
                                       metavar="")

    for command, help_text, func, args in commands:
        cmd_parser = subparsers.add_parser(command, help=help_text)
        cmd_parser.set_defaults(func=func)

        for arg in args.keys():
            cmd_parser.add_argument(arg, **args[arg])

    args = parser.parse_args()
    args.func(args)
